{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst fs = require('../fs');\n\nconst {\n  pathExists\n} = require('../path-exists');\n\nconst u = require('universalify').fromPromise;\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\n\nasync function symlinkPaths(srcpath, dstpath) {\n  if (path.isAbsolute(srcpath)) {\n    try {\n      await fs.lstat(srcpath);\n    } catch (err) {\n      err.message = err.message.replace('lstat', 'ensureSymlink');\n      throw err;\n    }\n\n    return {\n      toCwd: srcpath,\n      toDst: srcpath\n    };\n  }\n\n  const dstdir = path.dirname(dstpath);\n  const relativeToDst = path.join(dstdir, srcpath);\n  const exists = await pathExists(relativeToDst);\n\n  if (exists) {\n    return {\n      toCwd: relativeToDst,\n      toDst: srcpath\n    };\n  }\n\n  try {\n    await fs.lstat(srcpath);\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureSymlink');\n    throw err;\n  }\n\n  return {\n    toCwd: srcpath,\n    toDst: path.relative(dstdir, srcpath)\n  };\n}\n\nfunction symlinkPathsSync(srcpath, dstpath) {\n  if (path.isAbsolute(srcpath)) {\n    const exists = fs.existsSync(srcpath);\n    if (!exists) throw new Error('absolute srcpath does not exist');\n    return {\n      toCwd: srcpath,\n      toDst: srcpath\n    };\n  }\n\n  const dstdir = path.dirname(dstpath);\n  const relativeToDst = path.join(dstdir, srcpath);\n  const exists = fs.existsSync(relativeToDst);\n\n  if (exists) {\n    return {\n      toCwd: relativeToDst,\n      toDst: srcpath\n    };\n  }\n\n  const srcExists = fs.existsSync(srcpath);\n  if (!srcExists) throw new Error('relative srcpath does not exist');\n  return {\n    toCwd: srcpath,\n    toDst: path.relative(dstdir, srcpath)\n  };\n}\n\nmodule.exports = {\n  symlinkPaths: u(symlinkPaths),\n  symlinkPathsSync\n};","map":{"version":3,"names":["path","require","fs","pathExists","u","fromPromise","symlinkPaths","srcpath","dstpath","isAbsolute","lstat","err","message","replace","toCwd","toDst","dstdir","dirname","relativeToDst","join","exists","relative","symlinkPathsSync","existsSync","Error","srcExists","module","exports"],"sources":["C:/Users/gayle/Dev/hydration-app/node_modules/gh-pages/node_modules/fs-extra/lib/ensure/symlink-paths.js"],"sourcesContent":["'use strict'\n\nconst path = require('path')\nconst fs = require('../fs')\nconst { pathExists } = require('../path-exists')\n\nconst u = require('universalify').fromPromise\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nasync function symlinkPaths (srcpath, dstpath) {\n  if (path.isAbsolute(srcpath)) {\n    try {\n      await fs.lstat(srcpath)\n    } catch (err) {\n      err.message = err.message.replace('lstat', 'ensureSymlink')\n      throw err\n    }\n\n    return {\n      toCwd: srcpath,\n      toDst: srcpath\n    }\n  }\n\n  const dstdir = path.dirname(dstpath)\n  const relativeToDst = path.join(dstdir, srcpath)\n\n  const exists = await pathExists(relativeToDst)\n  if (exists) {\n    return {\n      toCwd: relativeToDst,\n      toDst: srcpath\n    }\n  }\n\n  try {\n    await fs.lstat(srcpath)\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureSymlink')\n    throw err\n  }\n\n  return {\n    toCwd: srcpath,\n    toDst: path.relative(dstdir, srcpath)\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  if (path.isAbsolute(srcpath)) {\n    const exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      toCwd: srcpath,\n      toDst: srcpath\n    }\n  }\n\n  const dstdir = path.dirname(dstpath)\n  const relativeToDst = path.join(dstdir, srcpath)\n  const exists = fs.existsSync(relativeToDst)\n  if (exists) {\n    return {\n      toCwd: relativeToDst,\n      toDst: srcpath\n    }\n  }\n\n  const srcExists = fs.existsSync(srcpath)\n  if (!srcExists) throw new Error('relative srcpath does not exist')\n  return {\n    toCwd: srcpath,\n    toDst: path.relative(dstdir, srcpath)\n  }\n}\n\nmodule.exports = {\n  symlinkPaths: u(symlinkPaths),\n  symlinkPathsSync\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}