{"ast":null,"code":"var path = require('path');\n\nvar Git = require('./git.js');\n\nvar async = require('async');\n\nvar fs = require('fs-extra');\n/**\n * Generate a list of unique directory paths given a list of file paths.\n * @param {Array<string>} files List of file paths.\n * @return {Array<string>} List of directory paths.\n */\n\n\nfunction uniqueDirs(files) {\n  var dirs = new Set();\n  files.forEach(function (filepath) {\n    var parts = path.dirname(filepath).split(path.sep);\n    var partial = parts[0] || '/';\n    dirs.add(partial);\n\n    for (var i = 1, ii = parts.length; i < ii; ++i) {\n      partial = path.join(partial, parts[i]);\n      dirs.add(partial);\n    }\n  });\n  return Array.from(dirs);\n}\n\nexports.uniqueDirs = uniqueDirs;\n/**\n * Sort function for paths.  Sorter paths come first.  Paths of equal length are\n * sorted alphanumerically in path segment order.\n * @param {string} a First path.\n * @param {string} b Second path.\n * @return {number} Comparison.\n */\n\nfunction byShortPath(a, b) {\n  var aParts = a.split(path.sep);\n  var bParts = b.split(path.sep);\n  var aLength = aParts.length;\n  var bLength = bParts.length;\n  var cmp = 0;\n\n  if (aLength < bLength) {\n    cmp = -1;\n  } else if (aLength > bLength) {\n    cmp = 1;\n  } else {\n    var aPart, bPart;\n\n    for (var i = 0; i < aLength; ++i) {\n      aPart = aParts[i];\n      bPart = bParts[i];\n\n      if (aPart < bPart) {\n        cmp = -1;\n        break;\n      } else if (aPart > bPart) {\n        cmp = 1;\n        break;\n      }\n    }\n  }\n\n  return cmp;\n}\n\nexports.byShortPath = byShortPath;\n/**\n * Generate a list of directories to create given a list of file paths.\n * @param {Array<string>} files List of file paths.\n * @return {Array<string>} List of directory paths ordered by path length.\n */\n\nfunction dirsToCreate(files) {\n  return uniqueDirs(files).sort(byShortPath);\n}\n\nexports.dirsToCreate = dirsToCreate;\n/**\n * Copy a file.\n * @param {object} obj Object with src and dest properties.\n * @param {function(Error)} callback Callback\n */\n\nfunction copyFile(obj, callback) {\n  var called = false;\n\n  function done(err) {\n    if (!called) {\n      called = true;\n      callback(err);\n    }\n  }\n\n  var read = fs.createReadStream(obj.src);\n  read.on('error', function (err) {\n    done(err);\n  });\n  var write = fs.createWriteStream(obj.dest);\n  write.on('error', function (err) {\n    done(err);\n  });\n  write.on('close', function () {\n    done();\n  });\n  read.pipe(write);\n}\n\nexports.copyFile = copyFile;\n/**\n * Make directory, ignoring errors if directory already exists.\n * @param {string} path Directory path.\n * @param {function(Error)} callback Callback.\n */\n\nfunction makeDir(path, callback) {\n  fs.mkdir(path, function (err) {\n    if (err) {\n      // check if directory exists\n      fs.stat(path, function (err2, stat) {\n        if (err2 || !stat.isDirectory()) {\n          callback(err);\n        } else {\n          callback();\n        }\n      });\n    } else {\n      callback();\n    }\n  });\n}\n/**\n * Copy a list of files.\n * @param {Array<string>} files Files to copy.\n * @param {string} base Base directory.\n * @param {string} dest Destination directory.\n * @return {Promise} A promise.\n */\n\n\nexports.copy = function (files, base, dest) {\n  return new Promise(function (resolve, reject) {\n    var pairs = [];\n    var destFiles = [];\n    files.forEach(function (file) {\n      var src = path.resolve(base, file);\n      var relative = path.relative(base, src);\n      var target = path.join(dest, relative);\n      pairs.push({\n        src: src,\n        dest: target\n      });\n      destFiles.push(target);\n    });\n    async.eachSeries(dirsToCreate(destFiles), makeDir, function (err) {\n      if (err) {\n        return reject(err);\n      }\n\n      async.each(pairs, copyFile, function (err) {\n        if (err) {\n          return reject(err);\n        } else {\n          return resolve();\n        }\n      });\n    });\n  });\n};\n\nexports.getUser = function (cwd) {\n  return Promise.all([new Git(cwd).exec('config', 'user.name'), new Git(cwd).exec('config', 'user.email')]).then(function (results) {\n    return {\n      name: results[0].output.trim(),\n      email: results[1].output.trim()\n    };\n  }).catch(function (err) {\n    // git config exits with 1 if name or email is not set\n    return null;\n  });\n};","map":{"version":3,"names":["path","require","Git","async","fs","uniqueDirs","files","dirs","Set","forEach","filepath","parts","dirname","split","sep","partial","add","i","ii","length","join","Array","from","exports","byShortPath","a","b","aParts","bParts","aLength","bLength","cmp","aPart","bPart","dirsToCreate","sort","copyFile","obj","callback","called","done","err","read","createReadStream","src","on","write","createWriteStream","dest","pipe","makeDir","mkdir","stat","err2","isDirectory","copy","base","Promise","resolve","reject","pairs","destFiles","file","relative","target","push","eachSeries","each","getUser","cwd","all","exec","then","results","name","output","trim","email","catch"],"sources":["C:/Users/gayle/Dev/hydration-app/node_modules/gh-pages/lib/util.js"],"sourcesContent":["const path = require('path');\nconst Git = require('./git.js');\nconst async = require('async');\nconst fs = require('fs-extra');\n\n/**\n * Generate a list of unique directory paths given a list of file paths.\n * @param {Array<string>} files List of file paths.\n * @return {Array<string>} List of directory paths.\n */\nfunction uniqueDirs(files) {\n  const dirs = new Set();\n  files.forEach((filepath) => {\n    const parts = path.dirname(filepath).split(path.sep);\n    let partial = parts[0] || '/';\n    dirs.add(partial);\n    for (let i = 1, ii = parts.length; i < ii; ++i) {\n      partial = path.join(partial, parts[i]);\n      dirs.add(partial);\n    }\n  });\n  return Array.from(dirs);\n}\nexports.uniqueDirs = uniqueDirs;\n\n/**\n * Sort function for paths.  Sorter paths come first.  Paths of equal length are\n * sorted alphanumerically in path segment order.\n * @param {string} a First path.\n * @param {string} b Second path.\n * @return {number} Comparison.\n */\nfunction byShortPath(a, b) {\n  const aParts = a.split(path.sep);\n  const bParts = b.split(path.sep);\n  const aLength = aParts.length;\n  const bLength = bParts.length;\n  let cmp = 0;\n  if (aLength < bLength) {\n    cmp = -1;\n  } else if (aLength > bLength) {\n    cmp = 1;\n  } else {\n    let aPart, bPart;\n    for (let i = 0; i < aLength; ++i) {\n      aPart = aParts[i];\n      bPart = bParts[i];\n      if (aPart < bPart) {\n        cmp = -1;\n        break;\n      } else if (aPart > bPart) {\n        cmp = 1;\n        break;\n      }\n    }\n  }\n  return cmp;\n}\nexports.byShortPath = byShortPath;\n\n/**\n * Generate a list of directories to create given a list of file paths.\n * @param {Array<string>} files List of file paths.\n * @return {Array<string>} List of directory paths ordered by path length.\n */\nfunction dirsToCreate(files) {\n  return uniqueDirs(files).sort(byShortPath);\n}\nexports.dirsToCreate = dirsToCreate;\n\n/**\n * Copy a file.\n * @param {object} obj Object with src and dest properties.\n * @param {function(Error)} callback Callback\n */\nfunction copyFile(obj, callback) {\n  let called = false;\n  function done(err) {\n    if (!called) {\n      called = true;\n      callback(err);\n    }\n  }\n\n  const read = fs.createReadStream(obj.src);\n  read.on('error', (err) => {\n    done(err);\n  });\n\n  const write = fs.createWriteStream(obj.dest);\n  write.on('error', (err) => {\n    done(err);\n  });\n  write.on('close', () => {\n    done();\n  });\n\n  read.pipe(write);\n}\nexports.copyFile = copyFile;\n\n/**\n * Make directory, ignoring errors if directory already exists.\n * @param {string} path Directory path.\n * @param {function(Error)} callback Callback.\n */\nfunction makeDir(path, callback) {\n  fs.mkdir(path, (err) => {\n    if (err) {\n      // check if directory exists\n      fs.stat(path, (err2, stat) => {\n        if (err2 || !stat.isDirectory()) {\n          callback(err);\n        } else {\n          callback();\n        }\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\n/**\n * Copy a list of files.\n * @param {Array<string>} files Files to copy.\n * @param {string} base Base directory.\n * @param {string} dest Destination directory.\n * @return {Promise} A promise.\n */\nexports.copy = function (files, base, dest) {\n  return new Promise((resolve, reject) => {\n    const pairs = [];\n    const destFiles = [];\n    files.forEach((file) => {\n      const src = path.resolve(base, file);\n      const relative = path.relative(base, src);\n      const target = path.join(dest, relative);\n      pairs.push({\n        src: src,\n        dest: target,\n      });\n      destFiles.push(target);\n    });\n\n    async.eachSeries(dirsToCreate(destFiles), makeDir, (err) => {\n      if (err) {\n        return reject(err);\n      }\n      async.each(pairs, copyFile, (err) => {\n        if (err) {\n          return reject(err);\n        } else {\n          return resolve();\n        }\n      });\n    });\n  });\n};\n\nexports.getUser = function (cwd) {\n  return Promise.all([\n    new Git(cwd).exec('config', 'user.name'),\n    new Git(cwd).exec('config', 'user.email'),\n  ])\n    .then((results) => {\n      return {name: results[0].output.trim(), email: results[1].output.trim()};\n    })\n    .catch((err) => {\n      // git config exits with 1 if name or email is not set\n      return null;\n    });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}