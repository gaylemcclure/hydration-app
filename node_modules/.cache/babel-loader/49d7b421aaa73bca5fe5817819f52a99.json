{"ast":null,"code":"'use strict';\n\nvar forEach = require('for-each');\n\nvar availableTypedArrays = require('available-typed-arrays');\n\nvar callBind = require('call-bind');\n\nvar callBound = require('call-bind/callBound');\n\nvar gOPD = require('gopd');\n\nvar $toString = callBound('Object.prototype.toString');\n\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\nvar $slice = callBound('String.prototype.slice');\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\n\nvar $indexOf = callBound('Array.prototype.indexOf', true) ||\n/** @type {(array: readonly unknown[], value: unknown) => keyof array} */\nfunction indexOf(array, value) {\n  for (var i = 0; i < array.length; i += 1) {\n    if (array[i] === value) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/** @typedef {Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array} TypedArray */\n\n/** @typedef {'Int8Array' | 'Uint8Array' | 'Uint8ClampedArray' | 'Int16Array' | 'Uint16Array' | 'Int32Array' | 'Uint32Array' | 'Float32Array' | 'Float64Array' | 'BigInt64Array' | 'BigUint64Array'} TypedArrayName */\n\n/** @type {{ [k in `\\$${TypedArrayName}`]?: (receiver: TypedArray) => string | typeof Uint8Array.prototype.slice.call | typeof Uint8Array.prototype.set.call } & { __proto__: null }} */\n\n\nvar cache = {\n  __proto__: null\n};\n\nif (hasToStringTag && gOPD && getPrototypeOf) {\n  forEach(typedArrays, function (typedArray) {\n    var arr = new g[typedArray]();\n\n    if (Symbol.toStringTag in arr) {\n      var proto = getPrototypeOf(arr); // @ts-expect-error TS won't narrow inside a closure\n\n      var descriptor = gOPD(proto, Symbol.toStringTag);\n\n      if (!descriptor) {\n        var superProto = getPrototypeOf(proto); // @ts-expect-error TS won't narrow inside a closure\n\n        descriptor = gOPD(superProto, Symbol.toStringTag);\n      } // @ts-expect-error TODO: fix\n\n\n      cache['$' + typedArray] = callBind(descriptor.get);\n    }\n  });\n} else {\n  forEach(typedArrays, function (typedArray) {\n    var arr = new g[typedArray]();\n    var fn = arr.slice || arr.set;\n\n    if (fn) {\n      // @ts-expect-error TODO: fix\n      cache['$' + typedArray] = callBind(fn);\n    }\n  });\n}\n/** @type {import('.')} */\n\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n  /** @type {ReturnType<tryAllTypedArrays>} */\n  var found = false;\n  forEach( // eslint-disable-next-line no-extra-parens\n\n  /** @type {Record<`\\$${TypedArrayName}`, typeof cache>} */\n\n  /** @type {any} */\n  cache,\n  /** @type {(getter: typeof cache, name: `\\$${TypedArrayName}`) => void} */\n  function (getter, typedArray) {\n    if (!found) {\n      try {\n        // @ts-expect-error TODO: fix\n        if ('$' + getter(value) === typedArray) {\n          found = $slice(typedArray, 1);\n        }\n      } catch (e) {\n        /**/\n      }\n    }\n  });\n  return found;\n};\n/** @type {import('.')} */\n\n\nvar trySlices = function tryAllSlices(value) {\n  /** @type {ReturnType<tryAllSlices>} */\n  var found = false;\n  forEach( // eslint-disable-next-line no-extra-parens\n\n  /** @type {any} */\n  cache,\n  /** @type {(getter: typeof cache, name: `\\$${TypedArrayName}`) => void} */\n  function (getter, name) {\n    if (!found) {\n      try {\n        // @ts-expect-error TODO: fix\n        getter(value);\n        found = $slice(name, 1);\n      } catch (e) {\n        /**/\n      }\n    }\n  });\n  return found;\n};\n/** @type {import('.')} */\n\n\nmodule.exports = function whichTypedArray(value) {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n\n  if (!hasToStringTag) {\n    var tag = $slice($toString(value), 8, -1);\n\n    if ($indexOf(typedArrays, tag) > -1) {\n      return tag;\n    }\n\n    if (tag !== 'Object') {\n      return false;\n    } // node < 0.6 hits here on real Typed Arrays\n\n\n    return trySlices(value);\n  }\n\n  if (!gOPD) {\n    return null;\n  } // unknown engine\n\n\n  return tryTypedArrays(value);\n};","map":{"version":3,"names":["forEach","require","availableTypedArrays","callBind","callBound","gOPD","$toString","hasToStringTag","g","globalThis","global","typedArrays","$slice","getPrototypeOf","Object","$indexOf","indexOf","array","value","i","length","cache","__proto__","typedArray","arr","Symbol","toStringTag","proto","descriptor","superProto","get","fn","slice","set","tryTypedArrays","tryAllTypedArrays","found","getter","e","trySlices","tryAllSlices","name","module","exports","whichTypedArray","tag"],"sources":["C:/Users/gayle/Dev/hydration-app/node_modules/which-typed-array/index.js"],"sourcesContent":["'use strict';\n\nvar forEach = require('for-each');\nvar availableTypedArrays = require('available-typed-arrays');\nvar callBind = require('call-bind');\nvar callBound = require('call-bind/callBound');\nvar gOPD = require('gopd');\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $slice = callBound('String.prototype.slice');\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\n\nvar $indexOf = callBound('Array.prototype.indexOf', true) || /** @type {(array: readonly unknown[], value: unknown) => keyof array} */ function indexOf(array, value) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\n/** @typedef {Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array} TypedArray */\n/** @typedef {'Int8Array' | 'Uint8Array' | 'Uint8ClampedArray' | 'Int16Array' | 'Uint16Array' | 'Int32Array' | 'Uint32Array' | 'Float32Array' | 'Float64Array' | 'BigInt64Array' | 'BigUint64Array'} TypedArrayName */\n/** @type {{ [k in `\\$${TypedArrayName}`]?: (receiver: TypedArray) => string | typeof Uint8Array.prototype.slice.call | typeof Uint8Array.prototype.set.call } & { __proto__: null }} */\nvar cache = { __proto__: null };\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tif (Symbol.toStringTag in arr) {\n\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\t// @ts-expect-error TS won't narrow inside a closure\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\tif (!descriptor) {\n\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\t// @ts-expect-error TS won't narrow inside a closure\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t}\n\t\t\t// @ts-expect-error TODO: fix\n\t\t\tcache['$' + typedArray] = callBind(descriptor.get);\n\t\t}\n\t});\n} else {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tvar fn = arr.slice || arr.set;\n\t\tif (fn) {\n\t\t\t// @ts-expect-error TODO: fix\n\t\t\tcache['$' + typedArray] = callBind(fn);\n\t\t}\n\t});\n}\n\n/** @type {import('.')} */\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\t/** @type {ReturnType<tryAllTypedArrays>} */ var found = false;\n\tforEach(\n\t\t// eslint-disable-next-line no-extra-parens\n\t\t/** @type {Record<`\\$${TypedArrayName}`, typeof cache>} */ /** @type {any} */ (cache),\n\t\t/** @type {(getter: typeof cache, name: `\\$${TypedArrayName}`) => void} */ function (getter, typedArray) {\n\t\t\tif (!found) {\n\t\t\t\ttry {\n\t\t\t\t// @ts-expect-error TODO: fix\n\t\t\t\t\tif ('$' + getter(value) === typedArray) {\n\t\t\t\t\t\tfound = $slice(typedArray, 1);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) { /**/ }\n\t\t\t}\n\t\t}\n\t);\n\treturn found;\n};\n\n/** @type {import('.')} */\nvar trySlices = function tryAllSlices(value) {\n\t/** @type {ReturnType<tryAllSlices>} */ var found = false;\n\tforEach(\n\t\t// eslint-disable-next-line no-extra-parens\n\t\t/** @type {any} */ (cache),\n\t\t/** @type {(getter: typeof cache, name: `\\$${TypedArrayName}`) => void} */ function (getter, name) {\n\t\t\tif (!found) {\n\t\t\t\ttry {\n\t\t\t\t// @ts-expect-error TODO: fix\n\t\t\t\t\tgetter(value);\n\t\t\t\t\tfound = $slice(name, 1);\n\t\t\t\t} catch (e) { /**/ }\n\t\t\t}\n\t\t}\n\t);\n\treturn found;\n};\n\n/** @type {import('.')} */\nmodule.exports = function whichTypedArray(value) {\n\tif (!value || typeof value !== 'object') { return false; }\n\tif (!hasToStringTag) {\n\t\tvar tag = $slice($toString(value), 8, -1);\n\t\tif ($indexOf(typedArrays, tag) > -1) {\n\t\t\treturn tag;\n\t\t}\n\t\tif (tag !== 'Object') {\n\t\t\treturn false;\n\t\t}\n\t\t// node < 0.6 hits here on real Typed Arrays\n\t\treturn trySlices(value);\n\t}\n\tif (!gOPD) { return null; } // unknown engine\n\treturn tryTypedArrays(value);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}