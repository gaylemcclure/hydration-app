{"ast":null,"code":"'use strict';\n\nconst fs = require('../fs');\n\nconst path = require('path');\n\nconst {\n  mkdirs\n} = require('../mkdirs');\n\nconst {\n  pathExists\n} = require('../path-exists');\n\nconst {\n  utimesMillis\n} = require('../util/utimes');\n\nconst stat = require('../util/stat');\n\nasync function copy(src, dest) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (typeof opts === 'function') {\n    opts = {\n      filter: opts\n    };\n  }\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now\n\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber\n  // Warn about using preserveTimestamps on 32-bit node\n\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning('Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' + '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269', 'Warning', 'fs-extra-WARN0001');\n  }\n\n  const {\n    srcStat,\n    destStat\n  } = await stat.checkPaths(src, dest, 'copy', opts);\n  await stat.checkParentPaths(src, srcStat, dest, 'copy');\n  const include = await runFilter(src, dest, opts);\n  if (!include) return; // check if the parent of dest exists, and create it if it doesn't exist\n\n  const destParent = path.dirname(dest);\n  const dirExists = await pathExists(destParent);\n\n  if (!dirExists) {\n    await mkdirs(destParent);\n  }\n\n  await getStatsAndPerformCopy(destStat, src, dest, opts);\n}\n\nasync function runFilter(src, dest, opts) {\n  if (!opts.filter) return true;\n  return opts.filter(src, dest);\n}\n\nasync function getStatsAndPerformCopy(destStat, src, dest, opts) {\n  const statFn = opts.dereference ? fs.stat : fs.lstat;\n  const srcStat = await statFn(src);\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);\n  if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);\n  if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);\n  if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);\n  if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);\n  throw new Error(`Unknown file: ${src}`);\n}\n\nasync function onFile(srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts);\n\n  if (opts.overwrite) {\n    await fs.unlink(dest);\n    return copyFile(srcStat, src, dest, opts);\n  }\n\n  if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`);\n  }\n}\n\nasync function copyFile(srcStat, src, dest, opts) {\n  await fs.copyFile(src, dest);\n\n  if (opts.preserveTimestamps) {\n    // Make sure the file is writable before setting the timestamp\n    // otherwise open fails with EPERM when invoked with 'r+'\n    // (through utimes call)\n    if (fileIsNotWritable(srcStat.mode)) {\n      await makeFileWritable(dest, srcStat.mode);\n    } // Set timestamps and mode correspondingly\n    // Note that The initial srcStat.atime cannot be trusted\n    // because it is modified by the read(2) system call\n    // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n\n\n    const updatedSrcStat = await fs.stat(src);\n    await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);\n  }\n\n  return fs.chmod(dest, srcStat.mode);\n}\n\nfunction fileIsNotWritable(srcMode) {\n  return (srcMode & 0o200) === 0;\n}\n\nfunction makeFileWritable(dest, srcMode) {\n  return fs.chmod(dest, srcMode | 0o200);\n}\n\nasync function onDir(srcStat, destStat, src, dest, opts) {\n  // the dest directory might not exist, create it\n  if (!destStat) {\n    await fs.mkdir(dest);\n  }\n\n  const items = await fs.readdir(src); // loop through the files in the current directory to copy everything\n\n  await Promise.all(items.map(async item => {\n    const srcItem = path.join(src, item);\n    const destItem = path.join(dest, item); // skip the item if it is matches by the filter function\n\n    const include = await runFilter(srcItem, destItem, opts);\n    if (!include) return;\n    const {\n      destStat\n    } = await stat.checkPaths(srcItem, destItem, 'copy', opts); // If the item is a copyable file, `getStatsAndPerformCopy` will copy it\n    // If the item is a directory, `getStatsAndPerformCopy` will call `onDir` recursively\n\n    return getStatsAndPerformCopy(destStat, srcItem, destItem, opts);\n  }));\n\n  if (!destStat) {\n    await fs.chmod(dest, srcStat.mode);\n  }\n}\n\nasync function onLink(destStat, src, dest, opts) {\n  let resolvedSrc = await fs.readlink(src);\n\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc);\n  }\n\n  if (!destStat) {\n    return fs.symlink(resolvedSrc, dest);\n  }\n\n  let resolvedDest = null;\n\n  try {\n    resolvedDest = await fs.readlink(dest);\n  } catch (e) {\n    // dest exists and is a regular file or directory,\n    // Windows may throw UNKNOWN error. If dest already exists,\n    // fs throws error anyway, so no need to guard against it here.\n    if (e.code === 'EINVAL' || e.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest);\n    throw e;\n  }\n\n  if (opts.dereference) {\n    resolvedDest = path.resolve(process.cwd(), resolvedDest);\n  }\n\n  if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n    throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);\n  } // do not copy if src is a subdir of dest since unlinking\n  // dest in this case would result in removing src contents\n  // and therefore a broken symlink would be created.\n\n\n  if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n    throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);\n  } // copy the link\n\n\n  await fs.unlink(dest);\n  return fs.symlink(resolvedSrc, dest);\n}\n\nmodule.exports = copy;","map":{"version":3,"names":["fs","require","path","mkdirs","pathExists","utimesMillis","stat","copy","src","dest","opts","filter","clobber","overwrite","preserveTimestamps","process","arch","emitWarning","srcStat","destStat","checkPaths","checkParentPaths","include","runFilter","destParent","dirname","dirExists","getStatsAndPerformCopy","statFn","dereference","lstat","isDirectory","onDir","isFile","isCharacterDevice","isBlockDevice","onFile","isSymbolicLink","onLink","isSocket","Error","isFIFO","copyFile","unlink","errorOnExist","fileIsNotWritable","mode","makeFileWritable","updatedSrcStat","atime","mtime","chmod","srcMode","mkdir","items","readdir","Promise","all","map","item","srcItem","join","destItem","resolvedSrc","readlink","resolve","cwd","symlink","resolvedDest","e","code","isSrcSubdir","module","exports"],"sources":["C:/Users/gayle/Dev/hydration-app/node_modules/gh-pages/node_modules/fs-extra/lib/copy/copy.js"],"sourcesContent":["'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst { mkdirs } = require('../mkdirs')\nconst { pathExists } = require('../path-exists')\nconst { utimesMillis } = require('../util/utimes')\nconst stat = require('../util/stat')\n\nasync function copy (src, dest, opts = {}) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning(\n      'Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' +\n      '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269',\n      'Warning', 'fs-extra-WARN0001'\n    )\n  }\n\n  const { srcStat, destStat } = await stat.checkPaths(src, dest, 'copy', opts)\n\n  await stat.checkParentPaths(src, srcStat, dest, 'copy')\n\n  const include = await runFilter(src, dest, opts)\n\n  if (!include) return\n\n  // check if the parent of dest exists, and create it if it doesn't exist\n  const destParent = path.dirname(dest)\n  const dirExists = await pathExists(destParent)\n  if (!dirExists) {\n    await mkdirs(destParent)\n  }\n\n  await getStatsAndPerformCopy(destStat, src, dest, opts)\n}\n\nasync function runFilter (src, dest, opts) {\n  if (!opts.filter) return true\n  return opts.filter(src, dest)\n}\n\nasync function getStatsAndPerformCopy (destStat, src, dest, opts) {\n  const statFn = opts.dereference ? fs.stat : fs.lstat\n  const srcStat = await statFn(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n\n  if (\n    srcStat.isFile() ||\n    srcStat.isCharacterDevice() ||\n    srcStat.isBlockDevice()\n  ) return onFile(srcStat, destStat, src, dest, opts)\n\n  if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n  if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)\n  if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)\n  throw new Error(`Unknown file: ${src}`)\n}\n\nasync function onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n\n  if (opts.overwrite) {\n    await fs.unlink(dest)\n    return copyFile(srcStat, src, dest, opts)\n  }\n  if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nasync function copyFile (srcStat, src, dest, opts) {\n  await fs.copyFile(src, dest)\n  if (opts.preserveTimestamps) {\n    // Make sure the file is writable before setting the timestamp\n    // otherwise open fails with EPERM when invoked with 'r+'\n    // (through utimes call)\n    if (fileIsNotWritable(srcStat.mode)) {\n      await makeFileWritable(dest, srcStat.mode)\n    }\n\n    // Set timestamps and mode correspondingly\n\n    // Note that The initial srcStat.atime cannot be trusted\n    // because it is modified by the read(2) system call\n    // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n    const updatedSrcStat = await fs.stat(src)\n    await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime)\n  }\n\n  return fs.chmod(dest, srcStat.mode)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode) {\n  return fs.chmod(dest, srcMode | 0o200)\n}\n\nasync function onDir (srcStat, destStat, src, dest, opts) {\n  // the dest directory might not exist, create it\n  if (!destStat) {\n    await fs.mkdir(dest)\n  }\n\n  const items = await fs.readdir(src)\n\n  // loop through the files in the current directory to copy everything\n  await Promise.all(items.map(async item => {\n    const srcItem = path.join(src, item)\n    const destItem = path.join(dest, item)\n\n    // skip the item if it is matches by the filter function\n    const include = await runFilter(srcItem, destItem, opts)\n    if (!include) return\n\n    const { destStat } = await stat.checkPaths(srcItem, destItem, 'copy', opts)\n\n    // If the item is a copyable file, `getStatsAndPerformCopy` will copy it\n    // If the item is a directory, `getStatsAndPerformCopy` will call `onDir` recursively\n    return getStatsAndPerformCopy(destStat, srcItem, destItem, opts)\n  }))\n\n  if (!destStat) {\n    await fs.chmod(dest, srcStat.mode)\n  }\n}\n\nasync function onLink (destStat, src, dest, opts) {\n  let resolvedSrc = await fs.readlink(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n  if (!destStat) {\n    return fs.symlink(resolvedSrc, dest)\n  }\n\n  let resolvedDest = null\n  try {\n    resolvedDest = await fs.readlink(dest)\n  } catch (e) {\n    // dest exists and is a regular file or directory,\n    // Windows may throw UNKNOWN error. If dest already exists,\n    // fs throws error anyway, so no need to guard against it here.\n    if (e.code === 'EINVAL' || e.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest)\n    throw e\n  }\n  if (opts.dereference) {\n    resolvedDest = path.resolve(process.cwd(), resolvedDest)\n  }\n  if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n    throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n  }\n\n  // do not copy if src is a subdir of dest since unlinking\n  // dest in this case would result in removing src contents\n  // and therefore a broken symlink would be created.\n  if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n    throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n  }\n\n  // copy the link\n  await fs.unlink(dest)\n  return fs.symlink(resolvedSrc, dest)\n}\n\nmodule.exports = copy\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}